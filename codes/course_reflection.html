<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections</title>
    <style>
        /* General Styling */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background: linear-gradient(to right, #89f7fe, #66a6ff);
            color: #333;
        }

        h1 {
            text-align: center;
            color: #003366;
            animation: fadeIn 2s;
            margin-bottom: 30px;
        }

        h2 {
            color: #003366;
            margin-top: 20px;
        }

        p {
            margin: 10px 0;
        }

        ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        li {
            margin: 5px 0;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                margin: 10px;
            }

            h1 {
                font-size: 24px;
            }

            h2 {
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            body {
                font-size: 14px;
                margin: 5px;
            }

            h1 {
                font-size: 20px;
            }

            h2 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>

<h1>Algorithm Concepts and Applications</h1>

<h2>1. Kinds of Problems We See in Nature</h2>
<p>Problems in nature can be categorized based on how they are solved:</p>
<ul>
    <li><strong>Iteration:</strong> Solving problems step by step using loops (e.g., sum of numbers, traversing arrays).</li>
    <li><strong>Recursion:</strong> Breaking down a problem into smaller, simpler instances (e.g., Fibonacci sequence, Tower of Brahma).</li>
    <li><strong>Backtracking:</strong> Systematically exploring all solutions while discarding invalid options (e.g., N-Queens problem, maze navigation, Sudoku).</li>
</ul>

<h2>2. Space and Time Complexity</h2>
<p>
    <strong>Time Efficiency:</strong> Extra time taken by an algorithm to execute.<br>
    <strong>Space Efficiency:</strong> Extra space occupied by a program.
</p>
<p>Algorithms are classified by growth rates like <code>O(1)</code> (constant time) or <code>O(n²)</code> (quadratic time), which helps to understand their efficiency.</p>

<h2>3. Takeaway from Different Design Principles</h2>
<ul>
    <li><strong>Dynamic Programming:</strong> Avoids redundant calculations by storing intermediate results (e.g., knapsack problem).</li>
    <li><strong>Divide-and-Conquer:</strong> Breaks problems into smaller, manageable parts (e.g., merge sort, quick sort).</li>
</ul>

<h2>4. Hierarchical Data and Optimized Data Structures</h2>
<ul>
    <li><strong>Binary Trees:</strong> Store data hierarchically, with parent-child relationships.</li>
    <li><strong>Binary Search Trees (BST):</strong> Enable efficient searching and insertion.</li>
    <li><strong>Self-Balancing Trees:</strong> Ensure consistent performance (e.g., heaps, AVL trees, Red-Black trees).</li>
    <li><strong>Heaps:</strong> Ideal for priority queues; self-balancing.</li>
    <li><strong>Tries:</strong> Useful for autocomplete or dictionary lookups, though they require more space.</li>
</ul>

<h2>5. Need for Array Query Algorithms</h2>
<ul>
    <li><strong>Prefix Sum Arrays:</strong> Allow quick cumulative sum computations.</li>
    <li><strong>Fenwick Trees:</strong> Provide efficient prefix sums and updates.</li>
    <li><strong>Segment Trees:</strong> Offer range queries and updates.</li>
    <li><strong>Lookup Tables:</strong> Provide constant-time access for precomputed values.</li>
</ul>

<h2>6. Difference Between Trees and Graphs</h2>
<table border="1" cellpadding="10" cellspacing="0">
    <tr>
        <th>Feature</th>
        <th>Trees</th>
        <th>Graphs</th>
    </tr>
    <tr>
        <td>Structure</td>
        <td>Hierarchical, no cycles</td>
        <td>Can be non-hierarchical, may have cycles</td>
    </tr>
    <tr>
        <td>Applications</td>
        <td>Used in family trees, file directories</td>
        <td>Used in networks, social graphs</td>
    </tr>
    <tr>
        <td>Traversals</td>
        <td>Preorder, Inorder, Postorder</td>
        <td>DFS and BFS</td>
    </tr>
</table>

<h2>7. Sorting and Searching Fundamentals</h2>
<ul>
    <li><strong>Sorting Algorithms:</strong> Bubble sort, merge sort, quick sort.</li>
    <li><strong>Searching Algorithms:</strong> Linear search (unsorted data), binary search.</li>
</ul>

<h2>8. Graph Algorithms for Network Problems</h2>
<ul>
    <li><strong>Minimum Spanning Trees (MST):</strong> Kruskal’s and Prim’s algorithms optimize networks, like electrical grids.</li>
    <li><strong>Shortest Path Algorithms:</strong> Techniques like Dijkstra’s and Bellman-Ford are vital for routing and navigation systems.</li>
</ul>

</body>
</html>
